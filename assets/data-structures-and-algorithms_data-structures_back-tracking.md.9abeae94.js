import{_ as s,c as a,o as n,d as l}from"./app.a19d119d.js";const b=JSON.parse('{"title":"回溯算法","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是回溯算法","slug":"什么是回溯算法","link":"#什么是回溯算法","children":[]},{"level":2,"title":"回溯法的效率","slug":"回溯法的效率","link":"#回溯法的效率","children":[]},{"level":2,"title":"回溯法解决的问题","slug":"回溯法解决的问题","link":"#回溯法解决的问题","children":[]},{"level":2,"title":"如何理解回溯法","slug":"如何理解回溯法","link":"#如何理解回溯法","children":[]},{"level":2,"title":"回溯法模板","slug":"回溯法模板","link":"#回溯法模板","children":[]}],"relativePath":"data-structures-and-algorithms/data-structures/back-tracking.md","lastUpdated":1668835952000}'),p={name:"data-structures-and-algorithms/data-structures/back-tracking.md"},e=l(`<h1 id="回溯算法" tabindex="-1">回溯算法 <a class="header-anchor" href="#回溯算法" aria-hidden="true">#</a></h1><h2 id="什么是回溯算法" tabindex="-1">什么是回溯算法 <a class="header-anchor" href="#什么是回溯算法" aria-hidden="true">#</a></h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p><h2 id="回溯法的效率" tabindex="-1">回溯法的效率 <a class="header-anchor" href="#回溯法的效率" aria-hidden="true">#</a></h2><p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，因此并不高效。如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h2 id="回溯法解决的问题" tabindex="-1">回溯法解决的问题 <a class="header-anchor" href="#回溯法解决的问题" aria-hidden="true">#</a></h2><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="如何理解回溯法" tabindex="-1">如何理解回溯法 <a class="header-anchor" href="#如何理解回溯法" aria-hidden="true">#</a></h2><p>回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h2 id="回溯法模板" tabindex="-1">回溯法模板 <a class="header-anchor" href="#回溯法模板" aria-hidden="true">#</a></h2><p>回溯三部曲</p><ul><li>回溯函数模板返回值以及参数</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">backtracking</span><span style="color:#A6ACCD;">(参数)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>回溯函数的终止条件</li></ul><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (终止条件) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">存放结果</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>回溯搜索的遍历过程</li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">处理节点</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">backtracking</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">路径</span><span style="color:#F07178;">，</span><span style="color:#A6ACCD;">选择列表</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 递归</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">回溯</span><span style="color:#F07178;">，</span><span style="color:#A6ACCD;">撤销处理结果</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p>大家可以从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">backtracking</span><span style="color:#A6ACCD;">(参数) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">终止条件</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">存放结果</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">选择</span><span style="color:#F07178;">：</span><span style="color:#A6ACCD;">本层集合中元素</span><span style="color:#F07178;">（</span><span style="color:#A6ACCD;">树中节点孩子的数量就是集合的大小</span><span style="color:#F07178;">）) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">处理节点</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">backtracking</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">路径</span><span style="color:#F07178;">，</span><span style="color:#A6ACCD;">选择列表</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 递归</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">回溯</span><span style="color:#F07178;">，</span><span style="color:#A6ACCD;">撤销处理结果</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>`,24),r=[e];function o(c,t,i,y,d,F){return n(),a("div",null,r)}const D=s(p,[["render",o]]);export{b as __pageData,D as default};
