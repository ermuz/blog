import{_ as e,c as a,o as d,d as r}from"./app.a19d119d.js";const f=JSON.parse('{"title":"Vue.js 技术内幕","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue.js的整体设计","slug":"vue-js的整体设计","link":"#vue-js的整体设计","children":[{"level":3,"title":"Vue3 的优化","slug":"vue3-的优化","link":"#vue3-的优化","children":[]}]}],"relativePath":"framework-and-lib/frameworks/vue/technology-insider.md","lastUpdated":1669819636000}'),o={name:"framework-and-lib/frameworks/vue/technology-insider.md"},c=r('<h1 id="vue-js-技术内幕" tabindex="-1">Vue.js 技术内幕 <a class="header-anchor" href="#vue-js-技术内幕" aria-hidden="true">#</a></h1><h2 id="vue-js的整体设计" tabindex="-1">Vue.js的整体设计 <a class="header-anchor" href="#vue-js的整体设计" aria-hidden="true">#</a></h2><h3 id="vue3-的优化" tabindex="-1">Vue3 的优化 <a class="header-anchor" href="#vue3-的优化" aria-hidden="true">#</a></h3><h4 id="源码优化" tabindex="-1">源码优化 <a class="header-anchor" href="#源码优化" aria-hidden="true">#</a></h4><h5 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-hidden="true">#</a></h5><p><code>Vue3</code> 使用 <code>monorepo</code> 的方式进行维护，并根据功能将不同的模块拆分到 <code>packages</code> 目录下的不同子目录下。</p><p>模块拆分的颗粒度更细，职责划分更明确，模块之间的依赖关系也更加明显，使开发人员更容易阅读、李杰和更改所有模块的源码，提高了代码的可维护性。</p><h5 id="typescript" tabindex="-1">TypeScript <a class="header-anchor" href="#typescript" aria-hidden="true">#</a></h5><p><code>TypeScript</code> 提供了更好的类型检查，能支持复杂的类型推导。</p><h4 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-hidden="true">#</a></h4><h5 id="源码体积优化" tabindex="-1">源码体积优化 <a class="header-anchor" href="#源码体积优化" aria-hidden="true">#</a></h5><ul><li>移除冷门功能</li><li>引入 <code>tree-shaking</code> 技术，减小打包体积。</li></ul><h5 id="数据劫持优化" tabindex="-1">数据劫持优化 <a class="header-anchor" href="#数据劫持优化" aria-hidden="true">#</a></h5><p><code>Vue2</code> 存在的问题：</p><ul><li>使用 <code>Object.defineProperty</code> 劫持数据的 <code>getter</code> 和 <code>setter</code>，不能检测对象属性新增和删除。但提供了 <code>$set</code> 和 <code>$delete</code> ，会增加用户的心智负担。</li><li>嵌套层级较深的对象，需要进行递归遍历，会产生相当大的性能负担。</li></ul><p><code>Vue3</code> 使用 <code>Proxy</code> 能检测到对象属性的增加和删除，虽然无法侦听到深层次，但是 <code>Vue3</code> 是在 <code>Proxy</code> 对象处理器对象的 <code>getter</code> 中递归响应。只有真正访问到的内部对象才会变成响应式的，而不是“无脑”递归</p><h4 id="编译优化" tabindex="-1">编译优化 <a class="header-anchor" href="#编译优化" aria-hidden="true">#</a></h4><p><code>Vue3</code> 通过编译阶段对静态末班的分析，编译生成了 <code>Block Tree</code>。<code>Block Tree</code> 是将模版基于动态节点指令切割的嵌套区块，每个区块的内部结构都是固定的，而且每个区块只需要以一个Array来追踪自身包含的动态节点。</p><p>借助 Block Tree ,Vue3 将 vnode 的更新性能由与模版整体大小相关提升为与动态内容的数据量相关</p><h4 id="语法-api-优化" tabindex="-1">语法 API 优化 <a class="header-anchor" href="#语法-api-优化" aria-hidden="true">#</a></h4><p>Composition API</p>',21),i=[c];function t(h,n,s,l,u,p){return d(),a("div",null,i)}const m=e(o,[["render",t]]);export{f as __pageData,m as default};
