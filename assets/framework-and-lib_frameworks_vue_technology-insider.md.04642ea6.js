import{_ as e,c as a,o as s,d as n}from"./app.854f08c0.js";const m=JSON.parse('{"title":"Vue.js 技术内幕","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue.js的整体设计","slug":"vue-js的整体设计","link":"#vue-js的整体设计","children":[{"level":3,"title":"Vue3 的优化","slug":"vue3-的优化","link":"#vue3-的优化","children":[]},{"level":3,"title":"Vue3 源码总览","slug":"vue3-源码总览","link":"#vue3-源码总览","children":[]}]},{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[{"level":3,"title":"组件的渲染","slug":"组件的渲染","link":"#组件的渲染","children":[]}]}],"relativePath":"framework-and-lib/frameworks/vue/technology-insider.md","lastUpdated":1674879518000}'),r={name:"framework-and-lib/frameworks/vue/technology-insider.md"},l=n(`<h1 id="vue-js-技术内幕" tabindex="-1">Vue.js 技术内幕 <a class="header-anchor" href="#vue-js-技术内幕" aria-hidden="true">#</a></h1><h2 id="vue-js的整体设计" tabindex="-1">Vue.js的整体设计 <a class="header-anchor" href="#vue-js的整体设计" aria-hidden="true">#</a></h2><h3 id="vue3-的优化" tabindex="-1">Vue3 的优化 <a class="header-anchor" href="#vue3-的优化" aria-hidden="true">#</a></h3><h4 id="源码优化" tabindex="-1">源码优化 <a class="header-anchor" href="#源码优化" aria-hidden="true">#</a></h4><h5 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-hidden="true">#</a></h5><p><code>Vue3</code> 使用 <code>monorepo</code> 的方式进行维护，并根据功能将不同的模块拆分到 <code>packages</code> 目录下的不同子目录下。</p><p>模块拆分的颗粒度更细，职责划分更明确，模块之间的依赖关系也更加明显，使开发人员更容易阅读、李杰和更改所有模块的源码，提高了代码的可维护性。</p><h5 id="typescript" tabindex="-1">TypeScript <a class="header-anchor" href="#typescript" aria-hidden="true">#</a></h5><p><code>TypeScript</code> 提供了更好的类型检查，能支持复杂的类型推导。</p><h4 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-hidden="true">#</a></h4><h5 id="源码体积优化" tabindex="-1">源码体积优化 <a class="header-anchor" href="#源码体积优化" aria-hidden="true">#</a></h5><ul><li>移除冷门功能</li><li>引入 <code>tree-shaking</code> 技术，减小打包体积。</li></ul><h5 id="数据劫持优化" tabindex="-1">数据劫持优化 <a class="header-anchor" href="#数据劫持优化" aria-hidden="true">#</a></h5><p><code>Vue2</code> 存在的问题：</p><ul><li>使用 <code>Object.defineProperty</code> 劫持数据的 <code>getter</code> 和 <code>setter</code>，不能检测对象属性新增和删除。但提供了 <code>$set</code> 和 <code>$delete</code> ，会增加用户的心智负担。</li><li>嵌套层级较深的对象，需要进行递归遍历，会产生相当大的性能负担。</li></ul><p><code>Vue3</code> 使用 <code>Proxy</code> 能检测到对象属性的增加和删除，虽然无法侦听到深层次，但是 <code>Vue3</code> 是在 <code>Proxy</code> 对象处理器对象的 <code>getter</code> 中递归响应。只有真正访问到的内部对象才会变成响应式的，而不是“无脑”递归</p><h4 id="编译优化" tabindex="-1">编译优化 <a class="header-anchor" href="#编译优化" aria-hidden="true">#</a></h4><p><code>Vue3</code> 通过编译阶段对静态模版的分析，编译生成了 <code>Block Tree</code>。<code>Block Tree</code> 是将模版基于动态节点指令切割的嵌套区块，每个区块的内部结构都是固定的，而且每个区块只需要以一个Array来追踪自身包含的动态节点。</p><p>借助 <code>Block Tree</code> ,<code>Vue3</code> 将 <code>vnode</code> 的更新性能由与模版整体大小相关提升为与动态内容的数据量相关</p><h4 id="语法-api-优化" tabindex="-1">语法 API 优化 <a class="header-anchor" href="#语法-api-优化" aria-hidden="true">#</a></h4><p>Composition API</p><h3 id="vue3-源码总览" tabindex="-1">Vue3 源码总览 <a class="header-anchor" href="#vue3-源码总览" aria-hidden="true">#</a></h3><h4 id="源码目录结构" tabindex="-1">源码目录结构 <a class="header-anchor" href="#源码目录结构" aria-hidden="true">#</a></h4><div class="language-md line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">md</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">├── packages</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── compiler-core</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── compiler-dom</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── compiler-sfc</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── compiler-ssr</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── reactivity</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── reactivity-transform</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── runtime-core</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── runtime-dom</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── runtime-test</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── server-renderer</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── sfc-playground</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── shared</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── size-check</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── template-explorer</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── vue</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── vue-compat</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>compiler core</li><li>compiler dom</li><li></li></ul><h2 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-hidden="true">#</a></h2><h3 id="组件的渲染" tabindex="-1">组件的渲染 <a class="header-anchor" href="#组件的渲染" aria-hidden="true">#</a></h3><h4 id="什么是-vnode" tabindex="-1">什么是 <code>vnode</code> <a class="header-anchor" href="#什么是-vnode" aria-hidden="true">#</a></h4>`,28),c=[l];function i(o,d,p,t,h,u){return s(),a("div",null,c)}const A=e(r,[["render",i]]);export{m as __pageData,A as default};
