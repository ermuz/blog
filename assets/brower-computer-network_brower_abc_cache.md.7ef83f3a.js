import{_ as e,c as t,o as d,d as o}from"./app.854f08c0.js";const x=JSON.parse('{"title":"浏览器缓存","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是浏览器缓存","slug":"什么是浏览器缓存","link":"#什么是浏览器缓存","children":[]},{"level":2,"title":"浏览器缓存的分类","slug":"浏览器缓存的分类","link":"#浏览器缓存的分类","children":[{"level":3,"title":"强缓存","slug":"强缓存","link":"#强缓存","children":[]},{"level":3,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[]}]},{"level":2,"title":"用户行为对缓存的影响","slug":"用户行为对缓存的影响","link":"#用户行为对缓存的影响","children":[]}],"relativePath":"brower-computer-network/brower/abc/cache.md","lastUpdated":1674879518000}'),c={name:"brower-computer-network/brower/abc/cache.md"},a=o('<h1 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a></h1><h2 id="什么是浏览器缓存" tabindex="-1">什么是浏览器缓存 <a class="header-anchor" href="#什么是浏览器缓存" aria-hidden="true">#</a></h2><p><strong>浏览器缓存</strong>（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p><p>浏览器缓存有以下优点</p><ol><li>减少了冗余的数据传输、节省了网费</li><li>减少服务器的负担、大大提升网站的性能</li><li>加快了客户端加载网页的速度</li></ol><h2 id="浏览器缓存的分类" tabindex="-1">浏览器缓存的分类 <a class="header-anchor" href="#浏览器缓存的分类" aria-hidden="true">#</a></h2><p>主要分为两类：<strong>协商缓存</strong> 和 <strong>强缓存</strong>，也被称为 <strong>缓存协商</strong> 和 <strong>彻底缓存</strong>。</p><p>浏览器在第一次请求发生后，再次请求时：</p><ol><li>浏览器会先获取该资源缓存的 <code>header</code> 信息，根据其中的 <code>Expires</code> 和 <code>Cache-Control</code> 判断是否命中 <strong>强缓存</strong> ，若命中则直接从缓存中获取资源，包括缓存的 <code>header</code> 信息，本次请求不会与服务器进行通信</li><li>若没有命中 <strong>强缓存</strong>，浏览器会发送请求到服务器，该请求会携带首次请求返回的有关缓存的 <code>header</code> 字段信息(<code>Last-Modified</code>/<code>IF-Modified-Since</code>、<code>Etag</code>/<code>IF-None-Match</code>)，由服务器根据请求中的相关 <code>header</code> 信息来对比结果是否命中 <strong>协商缓存</strong> ，若命中，则服务器返回新的 <code>response header</code> 信息更新缓存中的对应 <code>header</code> 信息，但是不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</li></ol><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-hidden="true">#</a></h3><p><strong>强缓存</strong>是利用 <code>http</code> 的 <code>response header</code> 中的 <code>Expires</code> 或者 <code>Cache-Control</code> 两个字段来控制，用来表示资源的缓存时间。</p><h4 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-hidden="true">#</a></h4><p>该字段是 <code>http1.0</code> 时的规范，它的值为一个绝对时间的 <code>GMT</code> 的时间字符串，比如 <code>Expires: Mon,18 Oct 2066 23:59:59</code> 。这个时间代表这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于时间时间是一个绝对时间，所以当服务器与客户端时间偏差较大，就会导致缓存混乱。</p><h4 id="cache-control" tabindex="-1">Cache-Control <a class="header-anchor" href="#cache-control" aria-hidden="true">#</a></h4><p><code>Cache-Control</code> 是 <code>http1.1</code> 是出现的 <code>header</code> 信息，主要利用该字段的 <code>max-age</code> 值进行判断，它是一个相对时间，例如 <code>Cache-Control:max-age=3600</code> ，代表着资源的有效期是 <code>3600</code> 秒。</p><p>除了 <code>max-age</code> 还有下面几个比较常用的设置值</p><ul><li><code>public</code>: 客户端和服务器都可以缓存</li><li><code>privite</code>: 只有客户端可以缓存</li><li><code>no-cache</code>: 客户端缓存资源，但是是否缓存需要经过 <strong>协商缓存</strong> 来验证</li><li><code>no-store</code>: 不使用缓存</li></ul><p><code>Cache-Control</code> 与 <code>Expires</code> 可以在服务端配置同时启用，同时启用的时候 <code>Cache-Control</code> 优先级高。</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h3><p><strong>协商缓存</strong> 就是交由服务器来确定缓存是否可用，所以客户端和服务端要通过某种标识来进行通信，从而让服务器判断资源是否可以缓存访问，这主要设计到下面两组 <code>header</code> 字段，这两组搭档都是 <strong>成对</strong> 出现的，即第一次请求的response头带上某个字段（<code>Last-Modified</code> 或 <code>Etag</code>），则后需要请求都会带上对应的请求字段（<code>If-Modified-Since</code> 或 <code>If-None-Match</code>），若response头没有 <code>Last-Modified</code> 或 <code>Etag</code> 字段，则请求头也不会有对应字段。</p><h4 id="last-modify-if-modify-since" tabindex="-1">Last-Modify/If-Modify-Since <a class="header-anchor" href="#last-modify-if-modify-since" aria-hidden="true">#</a></h4><p>浏览器第一次请求一个资源的时候，服务器返回的 <code>header</code> 中会加上 <code>Last-Modify</code> ，<code>Last-modify</code> 是一个时间标识该资源的最后修改时间，例如 <code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。</p><p>当浏览器再次请求该资源时，请求头中会包含 <code>If-Modify-Since</code> ，该值为缓存之前返回的 <code>Last-Modify</code>。服务器收到 <code>If-Modify-Since</code> 后，根据资源的最后修改时间判断是否命中缓存。</p><p><strong>如果命中缓存，则返回 <code>304</code> ，并且不会返回资源内容，并且不会返回 <code>Last-Modify</code></strong>。</p><h4 id="etag-if-none-match" tabindex="-1">ETag/If-None-Match <a class="header-anchor" href="#etag-if-none-match" aria-hidden="true">#</a></h4><p>与 <code>Last-Modify</code> <code>If-Modify-Since</code> 不同的是，<code>Etag</code> <code>If-None-Match</code> 返回的是一个校验码。<code>ETag</code> 可以保证每一个资源是唯一的，资源变化都会导致<code>ETag</code>变化。服务器根据浏览器上送的<code>If-None-Match</code>值来判断是否命中缓存。</p><p>与 <code>Last-Modified</code> 不一样的是，当服务器返回 <code>304 Not Modified</code> 的response时，由于 <code>ETag</code> response <code>header</code> 中还会把这个 <code>ETag</code> 返回，即使这个 <code>ETag</code> 跟之前的没有变化。</p><h4 id="为什么要有etag" tabindex="-1">为什么要有Etag <a class="header-anchor" href="#为什么要有etag" aria-hidden="true">#</a></h4><p><code>HTTP1.1</code> 中 <code>Etag</code> 的出现主要是为了解决几个 <code>Last-Modified</code> 比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(<strong>仅仅改变的修改时间</strong>)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p><strong><code>Last-Modified</code> 与 <code>ETag</code> 是可以一起使用的，服务器会优先验证 <code>ETag</code> ，一致的情况下，才会继续比对<code>Last-Modified</code>，最后才决定是否返回<code>304</code></strong>。</p><p>强缓存与协商缓存的区别可以用下表来表示：</p><table><thead><tr><th style="text-align:center;">缓存类型</th><th style="text-align:center;">获取资源形式</th><th style="text-align:center;">状态码</th><th style="text-align:center;">发送请求到服务器</th></tr></thead><tbody><tr><td style="text-align:center;">强缓存</td><td style="text-align:center;">从缓存取</td><td style="text-align:center;">200（from cache）</td><td style="text-align:center;">否，直接从缓存取</td></tr><tr><td style="text-align:center;">协商缓存</td><td style="text-align:center;">从缓存取</td><td style="text-align:center;">304（Not Modified）</td><td style="text-align:center;">否，通过服务器来告知缓存是否可用</td></tr></tbody></table><h2 id="用户行为对缓存的影响" tabindex="-1">用户行为对缓存的影响 <a class="header-anchor" href="#用户行为对缓存的影响" aria-hidden="true">#</a></h2><table><thead><tr><th style="text-align:center;">用户操作</th><th style="text-align:center;">Expires/Cache-Control</th><th style="text-align:center;">Last-Modied/Etag</th></tr></thead><tbody><tr><td style="text-align:center;">地址栏回车</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">页面链接跳转</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">新开窗口</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">前进回退</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">F5刷新</td><td style="text-align:center;">❎</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">Ctrl+F5强制刷新</td><td style="text-align:center;">❎</td><td style="text-align:center;">❎</td></tr></tbody></table>',35),r=[a];function n(i,l,s,h,g,p){return d(),t("div",null,r)}const y=e(c,[["render",n]]);export{x as __pageData,y as default};
